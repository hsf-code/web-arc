---
title: http面试题（一）
date: 2020-05-29
categories: article
author: hsf
isTimeLine: true
---

# HTTP有哪些⽅法？

1. HTTP1.0定义了三种请求⽅法： GET, POST 和 HEAD⽅法 
2. HTTP1.1新增了五种请求⽅法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

### 这些⽅法的具体作⽤是什么？

1. GET: 通常⽤于请求服务器发送某些资源 
2. HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致. 该请求⽅法的⼀个使⽤场景是在 下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源 
3. OPTIONS: ⽤于获取⽬的资源所⽀持的通信选项 
4. POST: 发送数据给服务器 
5. PUT: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式 
6. DELETE: ⽤于删除指定的资源 
7. PATCH: ⽤于对资源进⾏部分修改 
8. CONNECT: HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器 
9. TRACE: 回显服务器收到的请求，主要⽤于测试或诊断 

### GET和POST有什么区别？ 

1. 数据传输⽅式不同：GET请求通过URL传输数据，⽽POST的数据通过请求体传输。 
2. 安全性不同：POST的数据因为在请求主体内，所以有⼀定的安全性保证，⽽GET的数据在URL中，通过历史记 录，缓存很容易查到数据信息。
3. 数据类型不同：GET只允许 ASCII 字符，⽽POST⽆限制 
4. GET⽆害： 刷新、后退等浏览器操作GET请求是⽆害的，POST可能重复提交表单 
5. 特性不同：GET是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的 概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽POST是⾮安全⾮幂等 

### PUT和POST都是给服务器发送新增资源，有什么区别？ 

1. PUT 和POST⽅法的区别是, PUT⽅法是幂等的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽POST⽅法是⾮幂 等的。 

2. 除此之外还有⼀个区别，通常情况下，PUT的URI指向是具体单⼀资源，⽽POST可以指向资源集合。 

   举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤ POST https://www.jianshu.com/articles ， 这个请求的语义是，在articles的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。 

⽽ PUT https://www.jianshu.com/articles/820357430 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』

```
『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性 
```

### 聊⼀聊HTTP的状态码有哪些？

##### 2XX 成功 

1. 200 OK，表示从客户端发来的请求在服务器端被正确处理 
2. 201 Created 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴ 
3. 202 Accepted 请求已接受，但是还没执⾏，不保证完成请求 
4. 204 No content，表示请求成功，但响应报⽂不含实体的主体部分 
5. 206 Partial Content，进⾏范围请求 

##### 3XX 重定向 

1. 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 
2. 302 found，临时性重定向，表示资源临时被分配了新的 URL 
3. 303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源 
4. 304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况 
5. 307 temporary redirect，临时重定向，和302含义相同 

##### 4XX 客户端错误 

1. 400 bad request，请求报⽂存在语法错误 
2. 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 
3. 403 forbidden，表示对请求资源的访问被服务器拒绝 
4. 404 not found，表示在服务器上没有找到请求的资源 
5. 408 Request timeout, 客户端请求超时 
6. 409 Confict, 请求的资源可能引起冲突 

##### 5XX 服务器错误 

1. 500 internal sever error，表示服务器端在执⾏请求时发⽣了错误 
2. 501 Not Implemented 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务 器不⽀持的某个⽅法 
3. 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求 
4. 505 http version not supported 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本

### 同样是重定向307，303，302的区别？

1. 302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。
2. 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 
3. 307会遵照浏览器标准， 不会从post变为get。

### HTTP的keep-alive是⼲什么的？

​		在早期的HTTP/1.0中，每次http请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，为了减少资源消耗， 缩短响应时间，就需要重⽤连接。在后来的HTTP/1.0中以及HTTP/1.1中，引⼊了重⽤连接的机制，就是在http请求头中 加⼊Connection: keep-alive来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。协议规定

HTTP/1.0如果想要保持⻓连接，需要在请求头中加上Connection: keep-alive。

##### keep-alive的优点： 

1. 较少的CPU和内存的使⽤（由于同时打开的连接的减少了） 
2. 允许请求和应答的HTTP管线化 
3. 降低拥塞控制 （TCP连接减少了）
4. 减少了后续请求的延迟（⽆需再进⾏握⼿） 
5. 报告错误⽆需关闭TCP连

### 为什么有了HTTP为什么还要HTTPS？

https是安全版的http，因为http协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS就 是为了解决HTTP的不安全⽽⽣的。

### HTTPS是如何保证安全的？

过程⽐较复杂，我们得先理解两个概念 

对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 

⾮对称加密： 

1. 私钥 + 公钥= 密钥对 
2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密 
3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅ 
4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密 

⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。 

解决⽅案： 

​	那么结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密 得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 

此时⼜带来⼀个问题，中间⼈问题： 

​	如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中 间⼈就可以轻松解密通信双⽅所发送的所有数据。 

所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。

​	证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等 

​	但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技 术，数字签名。 

​	数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签 名。

​	当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 

这个时候就能最⼤程度保证通信的安全了。



### HTTP2相对于HTTP1.x有什么优势和特点？

##### ⼆进制分帧 

​	帧：HTTP/2 数据通信的最⼩单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。 

​	流：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数ID HTTP/2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议解析起来更⾼效。

##### 头部压缩

HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。 

1. HTTP/2在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 
2. ⾸部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 
3. 每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 

`你可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量`

### 服务器推送

​	服务端可以在发送⻚⾯HTML时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。例如服务端 可以主动把JS和CSS⽂件推送给客户端，⽽不需要客户端解析HTML时再发送这些请求。 

​	服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端。

### 多路复⽤

HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的 TCP链接请求限制。 

HTTP2中： 

1. ​	同域名下所有通信都在单个连接上完成。 
2. ​	单个连接可以承载任意数量的双向数据流。 
3. ​	数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可 以重新组装



### HTTP的缓存的过程是怎样的？

通常情况下的步骤是: 

	1. 客户端向服务器发出请求，请求资源 
 	2. 服务器返回资源，并通过响应头决定缓存策略 
 	3. 客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来 
 	4. 在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存



### 什么时候会触发强缓存或者协商缓存？

##### 强缓存 

###### 强缓存离不开两个响应头 Expires 与 Cache-Control 

- Expires：Expires是http1.0提出的⼀个表示资源过期时间的header，它描述的是⼀个绝对时间，由服务器返回， Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 

`Expires: Wed, 11 May 2018 07:20:00 GMT` 

- Cache-Control: Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires ,表示的是相对时间

`Cache-Control: max-age=315360000`

###### ⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有⼀些不得不提

- Cache-Control: public可以被所有⽤户缓存，包括终端和CDN等中间代理服务器 
- Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存 
- Cache-Control: no-cache,先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤ 
- Cache-Control: no-store，不会产⽣任何缓存

在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。

### 协商缓存

当第⼀次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期抑或它的属性设 置为no-cache时，那么浏览器第⼆次请求时就会与服务器进⾏协商。

如果缓存和服务端资源的最新版本是⼀致的，那么就⽆需再次下载该资源，服务端直接返回304 Not Modified 状态码， 如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是 200 Ok。

服务器判断缓存是否是新鲜的⽅法就是依靠HTTP的另外两组信息

###### Last-Modified/If-Modified-Since

客户端⾸次请求资源时，服务器会把资源的最新修改时间 Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT 通过响应部⾸发 送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头 If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，如果服务器的资源更新，那么返回最新的资 源，此时状态码200，当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回304状态码， 表示客户端直接⽤缓存即可。

##### ETag/If-None-Match

ETag的流程跟Last-Modified是类似的，区别就在于ETag是根据资源内容进⾏hash，⽣成⼀个信息摘要，只要资源内容 有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，这⽐Last-Modified 的精确度要更⾼。

